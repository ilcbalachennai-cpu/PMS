
import * as XLSX from 'xlsx';
import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';
import { Employee, PayrollResult, StatutoryConfig, Attendance, LeaveLedger, AdvanceLedger, CompanyProfile } from '../types';
import { BRAND_CONFIG } from '../constants';

// --- Utility: Number to Words (Indian System) ---
export const numberToWords = (num: number): string => {
  const a = ['', 'One ', 'Two ', 'Three ', 'Four ', 'Five ', 'Six ', 'Seven ', 'Eight ', 'Nine ', 'Ten ', 'Eleven ', 'Twelve ', 'Thirteen ', 'Fourteen ', 'Fifteen ', 'Sixteen ', 'Seventeen ', 'Eighteen ', 'Nineteen '];
  const b = ['', '', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety'];

  const regex = /^(\d{2})(\d{2})(\d{2})(\d{1})(\d{2})$/;
  
  const getLT20 = (n: number) => a[Number(n)];
  const getGT20 = (n: number) => b[Number(n[0])] + ' ' + a[Number(n[1])];

  const numToWords = (input: number): string => {
    if (input === 0) return '';
    
    // Handle large numbers by breaking down
    if (input >= 10000000) { // Crore
        return numToWords(Math.floor(input / 10000000)) + 'Crore ' + numToWords(input % 10000000);
    }
    if (input >= 100000) { // Lakh
        return numToWords(Math.floor(input / 100000)) + 'Lakh ' + numToWords(input % 100000);
    }
    if (input >= 1000) { // Thousand
        return numToWords(Math.floor(input / 1000)) + 'Thousand ' + numToWords(input % 1000);
    }
    if (input >= 100) { // Hundred
        return numToWords(Math.floor(input / 100)) + 'Hundred ' + numToWords(input % 100);
    }
    
    // Less than 100
    if (input < 20) return getLT20(input);
    return getGT20(input.toString() as any); // Type cast for string index access
  };

  const integerPart = Math.floor(num);
  if (integerPart === 0) return 'Zero';
  
  return numToWords(integerPart).trim();
};

const MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

const getPeriodsInRange = (startMonth: string, startYear: number, endMonth: string, endYear: number) => {
    const periods: { month: string, year: number }[] = [];
    let currentYear = startYear;
    let currentMonthIdx = MONTHS.indexOf(startMonth);
    const endMonthIdx = MONTHS.indexOf(endMonth);

    // Safety break to prevent infinite loops if logic fails
    let safety = 0;
    while(safety < 60) { // Max 5 years
        periods.push({ month: MONTHS[currentMonthIdx], year: currentYear });

        if (currentYear === endYear && currentMonthIdx === endMonthIdx) break;

        currentMonthIdx++;
        if (currentMonthIdx > 11) {
            currentMonthIdx = 0;
            currentYear++;
        }
        safety++;
    }
    return periods;
};

export const generateExcelReport = (data: any[], sheetName: string, fileName: string) => {
  const ws = XLSX.utils.json_to_sheet(data);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, sheetName);
  XLSX.writeFile(wb, `${fileName}.xlsx`);
};

export const generatePDFTableReport = (
  title: string,
  headers: string[],
  data: (string | number)[][],
  fileName: string,
  orientation: 'p' | 'l' = 'l',
  footnote?: string,
  companyProfile?: CompanyProfile
) => {
  const doc = new jsPDF(orientation, 'mm', 'a4');
  
  // Header - Uses Company Profile or Fallback
  doc.setFontSize(18);
  const companyName = companyProfile?.establishmentName || BRAND_CONFIG.companyName;
  doc.text(companyName, 14, 15);

  // Address - Small Font below Company Name
  doc.setFontSize(8);
  if (companyProfile) {
      const addressLine = `${companyProfile.address}, ${companyProfile.city}, ${companyProfile.state}`.replace(/,\s*,/g, ',');
      doc.text(addressLine, 14, 19);
  }

  doc.setFontSize(11);
  doc.setTextColor(100);
  // Adjusted Y position to account for address line
  doc.text(title, 14, 24);
  doc.setTextColor(0);

  // Table - Adjusted StartY
  autoTable(doc, {
    head: [headers],
    body: data,
    startY: 32,
    theme: 'grid',
    headStyles: { fillColor: [41, 128, 185], textColor: 255, fontSize: 8 },
    bodyStyles: { fontSize: 7 }, // Smaller font for many columns
    styles: { cellPadding: 1 }
  });

  // Footer & Footnote
  const pageCount = doc.getNumberOfPages();
  const finalY = (doc as any).lastAutoTable.finalY + 10;

  if (footnote) {
      doc.setFontSize(8);
      doc.setFont("helvetica", "italic");
      doc.setTextColor(0); // Black for visibility
      // Ensure footnote doesn't go off page
      const printY = finalY > doc.internal.pageSize.height - 20 ? doc.internal.pageSize.height - 20 : finalY;
      const splitFootnote = doc.splitTextToSize(footnote, 180);
      doc.text(splitFootnote, 14, printY);
  }

  for(let i = 1; i <= pageCount; i++) {
     doc.setPage(i);
     doc.setFontSize(8);
     doc.setTextColor(150);
     doc.text(`Generated by ${BRAND_CONFIG.appName} on ${new Date().toLocaleDateString()}`, 14, doc.internal.pageSize.height - 10);
     doc.text(`Page ${i} of ${pageCount}`, doc.internal.pageSize.width - 25, doc.internal.pageSize.height - 10);
  }

  doc.save(`${fileName}.pdf`);
};

export const generateSimplePaySheetPDF = (
  results: PayrollResult[],
  employees: Employee[],
  month: string,
  year: number,
  companyProfile?: CompanyProfile
) => {
  const headers = [
    'ID', 'Name', 'Days', 
    'Basic', 'DA', 'Retn', 'HRA', 'Conv', 'Spec', 'Othr', 'Encash', 'GROSS', // Earnings
    'PF', 'VPF', 'ESI', 'PT', 'TDS', 'LWF', 'Adv', 'DED', // Deductions
    'NET PAY'
  ];
  
  let hasCode88 = false;
  let hasESICode = false;

  const data = results.map(r => {
    const emp = employees.find(e => e.id === r.employeeId);
    const special = r.earnings.special1 + r.earnings.special2 + r.earnings.special3;
    const other = r.earnings.washing + r.earnings.attire;
    
    if (r.isCode88) hasCode88 = true;
    if (r.isESICodeWagesUsed) hasESICode = true;

    // Add Asterisk to PF amount if Code 88 applies
    const pfDisplay = r.isCode88 
        ? `${Math.round(r.deductions.epf)}*` 
        : Math.round(r.deductions.epf);

    // Add Double Asterisk to ESI amount if Code Wages used
    const esiDisplay = r.isESICodeWagesUsed
        ? `${Math.round(r.deductions.esi)}**`
        : Math.round(r.deductions.esi);

    return [
      r.employeeId,
      emp?.name || '',
      r.payableDays,
      Math.round(r.earnings.basic),
      Math.round(r.earnings.da),
      Math.round(r.earnings.retainingAllowance),
      Math.round(r.earnings.hra),
      Math.round(r.earnings.conveyance),
      Math.round(special),
      Math.round(other),
      Math.round(r.earnings.leaveEncashment),
      Math.round(r.earnings.total),
      pfDisplay, // Use formatted PF display
      Math.round(r.deductions.vpf),
      esiDisplay, // Use formatted ESI display
      Math.round(r.deductions.pt),
      Math.round(r.deductions.it),
      Math.round(r.deductions.lwf),
      Math.round(r.deductions.advanceRecovery),
      Math.round(r.deductions.total),
      Math.round(r.netPay)
    ];
  });
  
  let footnote = "";
  if (hasCode88) {
      footnote += "* PF calculated on Code Wages (Social Security Code 2020). ";
  }
  if (hasESICode) {
      footnote += "** ESI calculated on Code Wages (Social Security Code 2020).";
  }

  generatePDFTableReport(`Pay Sheet - ${month} ${year}`, headers, data as any[][], `PaySheet_${month}_${year}`, 'l', footnote || undefined, companyProfile);
};

export const generatePaySlipsPDF = (
  payrollResults: PayrollResult[],
  employees: Employee[],
  month: string,
  year: number,
  companyProfile?: CompanyProfile
) => {
  const doc = new jsPDF('p', 'mm', 'a4');
  
  payrollResults.forEach((res, index) => {
    if (index > 0) doc.addPage();
    const emp = employees.find(e => e.id === res.employeeId);
    if (!emp) return;

    // --- Header ---
    doc.setFillColor(241, 245, 249); // Slate-100
    doc.rect(0, 0, 210, 40, 'F');
    
    doc.setFontSize(20);
    doc.setFont("helvetica", "bold");
    doc.setTextColor(30, 41, 59);
    // Dynamic Company Name
    const companyName = companyProfile?.establishmentName || BRAND_CONFIG.companyName;
    doc.text(companyName.toUpperCase(), 105, 18, { align: 'center' });
    
    doc.setFontSize(10);
    doc.setFont("helvetica", "normal");
    doc.setTextColor(71, 85, 105);
    // Dynamic Address
    const address = companyProfile 
        ? `${companyProfile.address}, ${companyProfile.city}, ${companyProfile.state}` 
        : "Industrial Estate, Chennai, Tamil Nadu";
    doc.text(address, 105, 25, { align: 'center' });
    
    doc.setFontSize(12);
    doc.setTextColor(15, 23, 42);
    doc.text(`PAY SLIP - ${month.toUpperCase()} ${year}`, 105, 35, { align: 'center' });

    // --- Employee Details Box ---
    doc.setDrawColor(203, 213, 225);
    doc.rect(14, 45, 182, 35);
    
    const leftX = 18;
    const rightX = 110;
    let y = 52;
    const inc = 6;

    doc.setFontSize(9);
    doc.setFont("helvetica", "bold");
    doc.text("Employee Name:", leftX, y);
    doc.setFont("helvetica", "normal");
    doc.text(emp.name, leftX + 30, y);
    
    doc.setFont("helvetica", "bold");
    doc.text("Designation:", rightX, y);
    doc.setFont("helvetica", "normal");
    doc.text(emp.designation, rightX + 25, y);

    y += inc;
    doc.setFont("helvetica", "bold");
    doc.text("Employee ID:", leftX, y);
    doc.setFont("helvetica", "normal");
    doc.text(emp.id, leftX + 30, y);

    doc.setFont("helvetica", "bold");
    doc.text("Department:", rightX, y);
    doc.setFont("helvetica", "normal");
    doc.text(emp.division, rightX + 25, y);

    y += inc;
    doc.setFont("helvetica", "bold");
    doc.text("Bank A/c:", leftX, y);
    doc.setFont("helvetica", "normal");
    doc.text(emp.bankAccount, leftX + 30, y);

    doc.setFont("helvetica", "bold");
    doc.text("Days Paid:", rightX, y);
    doc.setFont("helvetica", "normal");
    doc.text(`${res.payableDays} / ${res.daysInMonth}`, rightX + 25, y);
    
    y += inc;
    doc.setFont("helvetica", "bold");
    doc.text("UAN No:", leftX, y);
    doc.setFont("helvetica", "normal");
    doc.text(emp.uanc || 'N/A', leftX + 30, y);
    
    doc.setFont("helvetica", "bold");
    doc.text("PF No:", rightX, y);
    doc.setFont("helvetica", "normal");
    doc.text(emp.pfNumber || 'N/A', rightX + 25, y);
    y += inc;
    doc.setFont("helvetica", "bold");
    doc.text("ESI No:", leftX, y);
    doc.setFont("helvetica", "normal");
    doc.text(emp.esiNumber || 'N/A', leftX + 30, y);
    
    doc.setFont("helvetica", "bold");
    doc.text("PAN No:", rightX, y);
    doc.setFont("helvetica", "normal");
    doc.text(emp.pan || 'N/A', rightX + 25, y);

    // --- Financials Table ---
    const startY = 85;
    
     // PF Label Logic: Suffix asterisk to Label if applicable
    const pfLabel = res.isCode88 ? 'Provident Fund*' : 'Provident Fund';
    const pfAmount = res.deductions.epf.toFixed(2); 

    // ESI Label Logic: Suffix double asterisk to Label if applicable
    const esiLabel = res.isESICodeWagesUsed ? 'ESI**' : 'ESI';
    const esiAmount = res.deductions.esi.toFixed(2);

    autoTable(doc, {
        startY: startY,
        margin: { left: 14, right: 14 },
        head: [['Earnings', 'Amount (Rs.)', 'Deductions', 'Amount (Rs.)']],
        body: [
            ['Basic Pay', res.earnings.basic.toFixed(2), pfLabel, pfAmount ],
            ['DA', res.earnings.da.toFixed(2), esiLabel, esiAmount ],
            ['Retaining Allowance', res.earnings.retainingAllowance.toFixed(2), 'Professional Tax', res.deductions.pt.toFixed(2)],
            ['HRA', res.earnings.hra.toFixed(2), 'Income Tax Recovery', res.deductions.it.toFixed(2)],
            ['Conveyance', res.earnings.conveyance.toFixed(2), 'VPF', res.deductions.vpf.toFixed(2)],
            ['Special Allowance', (res.earnings.special1 + res.earnings.special2 + res.earnings.special3).toFixed(2), 'LWF', res.deductions.lwf.toFixed(2)],
            ['Other Allowances', (res.earnings.washing + res.earnings.attire).toFixed(2), 'Advance Recovery', res.deductions.advanceRecovery.toFixed(2)],
            ['Leave Encashment', res.earnings.leaveEncashment.toFixed(2), '', ''],
            [{ content: 'Total Earnings', styles: { fontStyle: 'bold', fillColor: [241, 245, 249] } }, { content: res.earnings.total.toFixed(2), styles: { fontStyle: 'bold', fillColor: [241, 245, 249] } }, { content: 'Total Deductions', styles: { fontStyle: 'bold', fillColor: [241, 245, 249] } }, { content: res.deductions.total.toFixed(2), styles: { fontStyle: 'bold', fillColor: [241, 245, 249] } }],
        ],
        theme: 'grid',
        headStyles: { fillColor: [51, 65, 85], textColor: 255, halign: 'center' },
        columnStyles: {
            0: { cellWidth: 65 },
            1: { cellWidth: 26, halign: 'right' },
            2: { cellWidth: 65 },
            3: { cellWidth: 26, halign: 'right' },
        }
    });

    // --- Net Pay Section ---
    const finalY = (doc as any).lastAutoTable.finalY + 10;
    
    doc.setDrawColor(59, 130, 246); // Blue border
    doc.setLineWidth(0.5);
    doc.rect(14, finalY, 182, 15);
    
    doc.setFontSize(11);
    doc.setFont("helvetica", "bold");
    doc.setTextColor(15, 23, 42);
    doc.text("NET SALARY PAYABLE:", 20, finalY + 10);
    
    doc.setFontSize(14);
    // Reverted to 'Rs.' to avoid font encoding issues with 'â‚¹' symbol in standard PDF fonts
    doc.text(`Rs. ${Math.round(res.netPay).toLocaleString('en-IN')}/-`, 180, finalY + 10, { align: 'right' });

    // --- Amount in Words ---
    doc.setFontSize(10);
    doc.setFont("helvetica", "bold");
    doc.setTextColor(30, 41, 59);
    const amountWords = numberToWords(Math.round(res.netPay));
    doc.text(`Amount in Words: ${amountWords} Rupees Only`, 14, finalY + 25);

    // --- Footnotes ---
    let footerY = finalY + 35;
    
    if (res.isCode88) {
        doc.setFontSize(8);
        doc.setFont("helvetica", "italic");
        doc.setTextColor(0);
        doc.text("* PF calculated on Code Wages (Social Security Code 2020)", 14, footerY);;
        footerY += 5;
    }
 if (res.isESICodeWagesUsed) {
        doc.setFontSize(8);
        doc.setFont("helvetica", "italic");
        doc.setTextColor(0);
        doc.text("** ESI calculated on Code Wages (Social Security Code 2020)", 14, footerY);
        footerY += 5;
    }
    // --- Footer ---
    doc.setFontSize(8);
    doc.setFont("helvetica", "italic");
    doc.setTextColor(148, 163, 184);
    doc.text("This is a computer-generated document and does not require a signature.", 105, footerY, { align: 'center' });
  });

  doc.save(`PaySlips_${month}_${year}.pdf`);
};

export const generateLeaveLedgerReport = (
    employees: Employee[],
    leaveLedgers: LeaveLedger[],
    attendances: Attendance[],
    month: string,
    year: number,
    type: 'BC' | 'AC', // BC: Before Confirmation (Opening + Eligible), AC: After Confirmation (Balance)
    companyProfile?: CompanyProfile
) => {
    const headers = [
        'ID', 'Name', 
        'EL Opening', 'EL Credit', 'EL Availed', 'EL Balance',
        'SL Opening', 'SL Credit', 'SL Availed', 'SL Balance',
        'CL Opening', 'CL Credit', 'CL Availed', 'CL Balance'
    ];

    const data = employees.map(emp => {
        const ledger = leaveLedgers.find(l => l.employeeId === emp.id);
        const att = attendances.find(a => a.employeeId === emp.id && a.month === month && a.year === year);
        
        // Defaults
        const elOpen = ledger?.el.opening || 0;
        const elCredit = ledger?.el.eligible || 0;
        const elAvailed = (att?.earnedLeave || 0) + (att?.encashedDays || 0); // Include encashment as usage
        
        // Logic check: If AC report, we show closing balance. If BC, we show Opening + Credit availability.
        // Actually, for reports:
        // BC = Report showing Opening and Credit available for the month.
        // AC = Report showing Final Balances after deduction.
        
        // Calculations
        // EL
        const elTotal = elOpen + elCredit;
        const elBalance = elTotal - elAvailed;

        // SL
        const slOpen = ledger?.sl.eligible || 0; // Assuming ledger stores current total eligible
        const slCredit = 0; // SL credit usually happens yearly or monthly, here simplified to ledger state
        const slAvailed = att?.sickLeave || 0;
        const slBalance = slOpen - slAvailed;

        // CL
        const clOpen = ledger?.cl.accumulation || 0;
        const clCredit = 0;
        const clAvailed = att?.casualLeave || 0;
        const clBalance = clOpen - clAvailed;

        return [
            emp.id,
            emp.name,
            elOpen, elCredit, elAvailed, elBalance,
            slOpen, slCredit, slAvailed, slBalance,
            clOpen, clCredit, clAvailed, clBalance
        ];
    });

    const reportTitle = type === 'BC' 
        ? `Leave Ledger (Before Confirmation) - ${month} ${year}` 
        : `Leave Ledger (After Confirmation) - ${month} ${year}`;
    
    const fileName = type === 'BC' ? `Leave_Ledger_BC_${month}_${year}` : `Leave_Ledger_AC_${month}_${year}`;

    generatePDFTableReport(reportTitle, headers, data as any[][], fileName, 'l', undefined, companyProfile);
};

// ... existing code ...
// (Other exports remain unchanged)
export const generatePFECR = (data: PayrollResult[], employees: Employee[], format: 'Excel' | 'Text', fileName: string) => {
    // Implementation for PF ECR
    const ecrData = data.map(r => {
        const emp = employees.find(e => e.id === r.employeeId);
        return {
            UAN: emp?.uanc,
            Name: emp?.name,
            Gross: r.earnings.total,
            EPF: r.earnings.basic + r.earnings.da + r.earnings.retainingAllowance, // Basic Wages
            EPS: Math.min(r.earnings.basic + r.earnings.da + r.earnings.retainingAllowance, 15000), // EPS Wages
            EDLI: Math.min(r.earnings.basic + r.earnings.da + r.earnings.retainingAllowance, 15000), // EDLI Wages
            EE_Share: r.deductions.epf,
            ER_Share_EPF: r.employerContributions.epf,
            ER_Share_EPS: r.employerContributions.eps,
            NCP_Days: r.daysInMonth - r.payableDays,
            Refund: 0
        };
    });

    if (format === 'Excel') {
        generateExcelReport(ecrData, 'ECR', fileName);
    } else {
        // Text format generation logic (simplified for now)
        const textContent = ecrData.map(d => Object.values(d).join('#~#')).join('\n');
        const blob = new Blob([textContent], { type: 'text/plain' });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${fileName}.txt`;
        a.click();
    }
};

export const generateESIReturn = (data: PayrollResult[], employees: Employee[], format: 'Excel' | 'Text', fileName: string, companyProfile: CompanyProfile) => {
    // Implementation for ESI Return
    const esiData = data.map(r => {
        const emp = employees.find(e => e.id === r.employeeId);
        return {
            IP_Number: emp?.esiNumber,
            IP_Name: emp?.name,
            No_of_Days: r.payableDays,
            Total_Monthly_Wages: r.earnings.total, // ESI Gross
            Reason_Code_Zero_Wages: r.payableDays === 0 ? 1 : 0,
            Last_Working_Day: ''
        };
    });
     generateExcelReport(esiData, 'ESI_Return', fileName);
};

export const generatePTReport = (data: PayrollResult[], employees: Employee[], fileName: string, companyProfile: CompanyProfile) => {
     const ptData = data.filter(r => r.deductions.pt > 0).map(r => {
        const emp = employees.find(e => e.id === r.employeeId);
        return {
            Emp_ID: r.employeeId,
            Name: emp?.name,
            Gross_Wages: r.earnings.total,
            PT_Deducted: r.deductions.pt
        };
    });
    generateExcelReport(ptData, 'Professional Tax', fileName);
};

export const generateTDSReport = (data: PayrollResult[], employees: Employee[], fileName: string, companyProfile: CompanyProfile) => {
     const tdsData = data.filter(r => r.deductions.it > 0).map(r => {
        const emp = employees.find(e => e.id === r.employeeId);
        return {
            Emp_ID: r.employeeId,
            Name: emp?.name,
            PAN: emp?.pan,
            Gross_Wages: r.earnings.total,
            TDS_Deducted: r.deductions.it
        };
    });
    generateExcelReport(tdsData, 'TDS Report', fileName);
};

export const generateCodeOnWagesReport = (data: PayrollResult[], employees: Employee[], format: 'Excel' | 'PDF', fileName: string, companyProfile: CompanyProfile) => {
    // Logic for Code on Wages 2020 impact (Code 88)
     const reportData = data.map(r => {
        const emp = employees.find(e => e.id === r.employeeId);
        const basicWages = r.earnings.basic + r.earnings.da + r.earnings.retainingAllowance;
        const totalWages = r.earnings.total;
        const excludedWages = totalWages - basicWages; // Roughly allowances
        const limit = totalWages * 0.5;
        const excess = excludedWages > limit ? excludedWages - limit : 0;
        const codeWages = basicWages + excess;
        
        return {
            Emp_ID: r.employeeId,
            Name: emp?.name,
            Gross_Wages: totalWages,
            Basic_DA: basicWages,
            Allowances: excludedWages,
            '50%_Limit': limit,
            Excess_Over_50: excess,
            Deemed_Wages: codeWages,
            PF_Wages_Used: r.isCode88 ? codeWages : Math.min(15000, basicWages) // approximate logic for display
        };
    });
    
    if (format === 'Excel') {
        generateExcelReport(reportData, 'Code on Wages', fileName);
    } else {
        const headers = ['ID', 'Name', 'Gross', 'Basic+DA', 'Allw', '50% Lim', 'Excess', 'Deemed Wages'];
        const tableData = reportData.map(d => [d.Emp_ID, d.Name, d.Gross_Wages, d.Basic_DA, d.Allowances, d['50%_Limit'], d.Excess_Over_50, d.Deemed_Wages]);
        generatePDFTableReport('Impact of Code on Wages, 2020', headers, tableData as any[][], fileName, 'l', undefined, companyProfile);
    }
};

export const generatePFForm12A = (data: PayrollResult[], employees: Employee[], config: StatutoryConfig, companyProfile: CompanyProfile, month: string, year: number) => {
    // Simplified PDF generation for Form 12A
     const headers = ['Group', 'Wages', 'A/c 01 (12%)', 'A/c 02', 'A/c 10 (8.33%)', 'A/c 21', 'A/c 22'];
     // Mock calculation
     const totalWages = data.reduce((acc, curr) => acc + (curr.earnings.basic + curr.earnings.da), 0);
     const totalEPF = data.reduce((acc, curr) => acc + curr.deductions.epf + curr.employerContributions.epf, 0);
     const tableData = [
         ['Total', totalWages.toFixed(2), totalEPF.toFixed(2), '0', '0', '0', '0']
     ];
     generatePDFTableReport(`PF Form 12A - ${month} ${year}`, headers, tableData, `Form12A_${month}_${year}`, 'p', undefined, companyProfile);
};

export const generatePFForm12 = (data: PayrollResult[], employees: Employee[], config: StatutoryConfig, month: string, year: number, companyProfile: CompanyProfile) => {
    // Similar to 12A
    generatePFForm12A(data, employees, config, companyProfile, month, year);
};

export const generateFormB = (data: PayrollResult[], employees: Employee[], month: string, year: number, companyProfile: CompanyProfile) => {
    // Register of Wages (Central)
    const headers = ['Sl', 'Name', 'Designation', 'Total Days', 'Total Wages', 'Deductions', 'Net Payable'];
    const tableData = data.map((r, i) => {
         const emp = employees.find(e => e.id === r.employeeId);
         return [i+1, emp?.name, emp?.designation, r.payableDays, r.earnings.total, r.deductions.total, r.netPay];
    });
    generatePDFTableReport(`Form B (Register of Wages) - ${month} ${year}`, headers, tableData as any[][], `FormB_${month}_${year}`, 'l', undefined, companyProfile);
};

export const generateCentralWageSlip = (data: PayrollResult[], employees: Employee[], month: string, year: number) => {
    // Just reuse payslip generator or create specific format
    // For now reusing PDF Table with just one row per page logically, but reusing generic table for simplicity in this stub
    // Ideally this calls generatePaySlipsPDF
    generatePaySlipsPDF(data, employees, month, year); 
};

export const generateFormC = (data: PayrollResult[], employees: Employee[], attendances: Attendance[], month: string, year: number, companyProfile: CompanyProfile) => {
    // Muster Roll
    const headers = ['Sl', 'Name', 'Father/Husband', 'Sex', 'Nature of Work', 'Attendance (Days)'];
    const tableData = data.map((r, i) => {
         const emp = employees.find(e => e.id === r.employeeId);
         const att = attendances.find(a => a.employeeId === r.employeeId && a.month === month && a.year === year);
         return [i+1, emp?.name, emp?.fatherSpouseName, emp?.gender || 'M', emp?.designation, att?.presentDays || 0];
    });
    generatePDFTableReport(`Form C (Muster Roll) - ${month} ${year}`, headers, tableData as any[][], `FormC_${month}_${year}`, 'l', undefined, companyProfile);
};

export const generateTNFormR = (data: PayrollResult[], employees: Employee[], month: string, year: number, companyProfile: CompanyProfile) => {
     generateFormB(data, employees, month, year, companyProfile); // Similar to Form B
};

export const generateTNFormT = (data: PayrollResult[], employees: Employee[], attendances: Attendance[], leaveLedgers: LeaveLedger[], month: string, year: number, companyProfile: CompanyProfile) => {
     // Wage Slip for TN
     // Reusing Pay Slip PDF logic
     generatePaySlipsPDF(data, employees, month, year, companyProfile);
};

export const generateTNFormP = (data: PayrollResult[], employees: Employee[], advanceLedgers: AdvanceLedger[], month: string, year: number, companyProfile: CompanyProfile) => {
     // Register of Advances
     const headers = ['Sl', 'Name', 'Date of Adv', 'Amount', 'Purpose', 'Installments', 'Recovered', 'Balance'];
     const tableData = advanceLedgers.map((adv, i) => {
         const emp = employees.find(e => e.id === adv.employeeId);
         const payroll = data.find(p => p.employeeId === adv.employeeId);
         const recovered = payroll ? payroll.deductions.advanceRecovery : 0;
         return [i+1, emp?.name, 'Various', adv.totalAdvance, 'Personal', adv.monthlyInstallment, recovered, adv.balance];
     });
     generatePDFTableReport(`Form P (Register of Advances) - ${month} ${year}`, headers, tableData as any[][], `FormP_${month}_${year}`, 'l', undefined, companyProfile);
};

export const generatePFForm3A = (history: PayrollResult[], employees: Employee[], config: StatutoryConfig, startMonth: string, startYear: number, endMonth: string, endYear: number, selectedEmployeeId?: string) => {
    // Annual Contribution Card
    // Filter history for range
    // If selectedEmployeeId is present, filter for that employee, else generate for all (might be huge PDF, but okay for stub)
    
    // Stub implementation: Just one summary PDF
    const headers = ['Month', 'Year', 'Wages', 'EPF', 'EPS', 'Total'];
    const tableData = history.filter(r => (selectedEmployeeId ? r.employeeId === selectedEmployeeId : true)).map(r => [r.month, r.year, r.earnings.total, r.deductions.epf, r.employerContributions.eps, r.deductions.epf + r.employerContributions.epf + r.employerContributions.eps]);
    
    generatePDFTableReport(`Form 3A (${startMonth} ${startYear} - ${endMonth} ${endYear})`, headers, tableData as any[][], `Form3A`, 'p');
};

export const generatePFForm6A = (history: PayrollResult[], employees: Employee[], config: StatutoryConfig, startMonth: string, startYear: number, endMonth: string, endYear: number) => {
     // Consolidated Annual Statement
     const headers = ['Sl', 'Name', 'UAN', 'Wages', 'EPF (EE)', 'EPF (ER)', 'EPS'];
     // Aggregate data per employee
     const agg: Record<string, any> = {};
     history.forEach(r => {
         if (!agg[r.employeeId]) agg[r.employeeId] = { wages: 0, epf_ee: 0, epf_er: 0, eps: 0 };
         agg[r.employeeId].wages += r.earnings.total;
         agg[r.employeeId].epf_ee += r.deductions.epf;
         agg[r.employeeId].epf_er += r.employerContributions.epf;
         agg[r.employeeId].eps += r.employerContributions.eps;
     });
     
     const tableData = Object.keys(agg).map((id, i) => {
         const emp = employees.find(e => e.id === id);
         const d = agg[id];
         return [i+1, emp?.name, emp?.uanc, d.wages, d.epf_ee, d.epf_er, d.eps];
     });
     
     generatePDFTableReport(`Form 6A (${startMonth} ${startYear} - ${endMonth} ${endYear})`, headers, tableData as any[][], `Form6A`, 'l');
};

export const generateESIExitReport = (data: PayrollResult[], employees: Employee[], month: string, year: number, companyProfile: CompanyProfile) => {
     const exitData = data.filter(r => r.esiRemark === 'IP is out of coverage').map(r => {
         const emp = employees.find(e => e.id === r.employeeId);
         return {
             ID: r.employeeId,
             Name: emp?.name,
             Gross_Wages: r.earnings.total,
             Reason: r.esiRemark
         };
     });
     generateExcelReport(exitData, 'ESI Exit List', `ESI_Exit_${month}_${year}`);
};

export const generateESICodeWagesReport = (data: PayrollResult[], employees: Employee[], format: 'Excel' | 'PDF', fileName: string, companyProfile: CompanyProfile) => {
    // Similar to Code on Wages but filtered for ESI relevance
    const reportData = data.filter(r => r.isESICodeWagesUsed).map(r => {
        const emp = employees.find(e => e.id === r.employeeId);
        return {
            ID: r.employeeId,
            Name: emp?.name,
            Actual_Gross: r.earnings.total,
            ESI_Code_Wages: r.earnings.total // Simplified for stub, logic in payrollEngine handles the calc
        };
    });
    
    if (format === 'Excel') {
        generateExcelReport(reportData, 'ESI Code Wages', fileName);
    } else {
        const headers = ['ID', 'Name', 'Actual Gross', 'ESI Code Wages'];
        const tableData = reportData.map(d => [d.ID, d.Name, d.Actual_Gross, d.ESI_Code_Wages]);
        generatePDFTableReport('ESI Contribution on Code Wages', headers, tableData as any[][], fileName, 'p', undefined, companyProfile);
    }
};
