
import * as XLSX from 'xlsx';
import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';
import { Employee, PayrollResult, StatutoryConfig, Attendance, LeaveLedger, AdvanceLedger, CompanyProfile } from '../types';
import { BRAND_CONFIG } from '../constants';

// --- Utility: Format Date to Indian Format (DD-MM-YYYY) ---
export const formatDateInd = (dateStr?: string | null): string => {
  if (!dateStr) return 'N/A';
  // If already in dd-mm-yyyy format, return as is
  if (/^\d{2}-\d{2}-\d{4}$/.test(dateStr)) return dateStr;
  
  try {
    const date = new Date(dateStr);
    if (isNaN(date.getTime())) return dateStr;
    const d = String(date.getDate()).padStart(2, '0');
    const m = String(date.getMonth() + 1).padStart(2, '0');
    const y = date.getFullYear();
    return `${d}-${m}-${y}`;
  } catch (e) {
    return dateStr;
  }
};

// --- Utility: Number to Words (Indian System) ---
export const numberToWords = (num: number): string => {
  const a = ['', 'One ', 'Two ', 'Three ', 'Four ', 'Five ', 'Six ', 'Seven ', 'Eight ', 'Nine ', 'Ten ', 'Eleven ', 'Twelve ', 'Thirteen ', 'Fourteen ', 'Fifteen ', 'Sixteen ', 'Seventeen ', 'Eighteen ', 'Nineteen '];
  const b = ['', '', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety'];

  const numToWordsInner = (input: number): string => {
    if (input === 0) return '';
    if (input >= 10000000) return numToWordsInner(Math.floor(input / 10000000)) + 'Crore ' + numToWordsInner(input % 10000000);
    if (input >= 100000) return numToWordsInner(Math.floor(input / 100000)) + 'Lakh ' + numToWordsInner(input % 100000);
    if (input >= 1000) return numToWordsInner(Math.floor(input / 1000)) + 'Thousand ' + numToWordsInner(input % 100);
    if (input >= 100) return numToWordsInner(Math.floor(input / 100)) + 'Hundred ' + numToWordsInner(input % 100);
    if (input < 20) return a[input];
    const s = input.toString();
    return b[parseInt(s[0])] + ' ' + a[parseInt(s[1])];
  };

  const integerPart = Math.floor(num);
  if (integerPart === 0) return 'Zero';
  return numToWordsInner(integerPart).trim();
};

const MONTHS = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

const buildAddressString = (profile?: CompanyProfile) => {
    if (!profile) return "Industrial Estate, Chennai, Tamil Nadu";
    const parts = [
        profile.doorNo,
        profile.buildingName,
        profile.street,
        profile.locality,
        profile.area,
        profile.city,
        profile.state,
        profile.pincode
    ].filter(Boolean);
    return parts.join(', ');
};

export const generateExcelReport = (data: any[], sheetName: string, fileName: string) => {
  const ws = XLSX.utils.json_to_sheet(data);
  const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, sheetName);
  XLSX.writeFile(wb, `${fileName}.xlsx`);
};

export const generatePDFTableReport = (
  title: string,
  headers: string[],
  data: (string | number)[][],
  fileName: string,
  orientation: 'p' | 'l' = 'l',
  footnote?: string,
  companyProfile?: CompanyProfile
) => {
  const doc = new jsPDF(orientation, 'mm', 'a4');
  doc.setFontSize(18);
  const companyName = companyProfile?.establishmentName || BRAND_CONFIG.companyName;
  doc.text(companyName, 14, 15);

  doc.setFontSize(8);
  if (companyProfile) {
      const addressLine = buildAddressString(companyProfile);
      doc.text(addressLine, 14, 19);
  }

  doc.setFontSize(11);
  doc.setTextColor(100);
  doc.text(title, 14, 24);
  doc.setTextColor(0);

  autoTable(doc, {
    head: [headers],
    body: data,
    startY: 32,
    theme: 'grid',
    headStyles: { fillColor: [41, 128, 185], textColor: 255, fontSize: 8 },
    bodyStyles: { fontSize: 7 },
    styles: { cellPadding: 1 }
  });

  const pageCount = doc.getNumberOfPages();
  const finalY = (doc as any).lastAutoTable.finalY + 10;

  if (footnote) {
      doc.setFontSize(8);
      doc.setFont("helvetica", "italic");
      doc.setTextColor(0, 0, 128); // Navy Blue
      const printY = finalY > doc.internal.pageSize.height - 20 ? doc.internal.pageSize.height - 20 : finalY;
      const splitFootnote = doc.splitTextToSize(footnote, 180);
      doc.text(splitFootnote, 14, printY);
  }

  for(let i = 1; i <= pageCount; i++) {
     doc.setPage(i);
     doc.setFontSize(8);
     doc.setTextColor(150);
     doc.text(`Generated by ${BRAND_CONFIG.appName} on ${formatDateInd(new Date().toISOString())}`, 14, doc.internal.pageSize.height - 10);
     doc.text(`Page ${i} of ${pageCount}`, doc.internal.pageSize.width - 25, doc.internal.pageSize.height - 10);
  }

  doc.save(`${fileName}.pdf`);
};

export const generateAdvanceShortfallReport = (
  shortfalls: any[],
  month: string,
  year: number,
  format: 'PDF' | 'Excel',
  companyProfile: CompanyProfile
) => {
  const fileName = `Advance_Recovery_Shortfall_${month}_${year}`;

  if (format === 'Excel') {
    const data = shortfalls.map(s => ({
        'Employee ID': s.id,
        'Name': s.name,
        'Paid Days': s.days,
        'Gross Wages': s.gross,
        'Target Advance': s.target,
        'Recovered': s.recovered,
        'Shortfall': s.shortfall,
        'Reason': s.days === 0 ? 'Zero Days Worked' : 'Insufficient Wages'
    }));
    generateExcelReport(data, 'Shortfalls', fileName);
  } else {
    const headers = ['ID', 'Name', 'Days', 'Gross', 'Target', 'Recvd', 'Shortfall', 'Remark'];
    const rows = shortfalls.map(s => [
        s.id, s.name, s.days, 
        s.gross.toLocaleString(), 
        s.target.toLocaleString(), 
        s.recovered.toLocaleString(), 
        s.shortfall.toLocaleString(),
        s.days === 0 ? 'Zero Days' : 'Low Wage'
    ]);
    
    generatePDFTableReport(
        `Advance Recovery Shortfall - ${month} ${year}`,
        headers,
        rows,
        fileName,
        'p',
        "Note: These advances could not be recovered fully due to lack of sufficient net wages or attendance.",
        companyProfile
    );
  }
};

export const generateGratuityReport = (employees: Employee[], companyProfile: CompanyProfile) => {
    const headers = ['Sl', 'Emp ID', 'Name', 'DOJ', 'Yrs Service', 'Monthly Wage (Basic+DA)', 'Gratuity Payable'];
    const today = new Date();
    
    const data = employees.map((emp, i) => {
        const doj = new Date(emp.doj);
        const diffMs = today.getTime() - doj.getTime();
        const years = Math.floor(diffMs / (1000 * 60 * 60 * 24 * 365.25));
        
        const monthlyWage = emp.basicPay + (emp.da || 0);
        const gratuityAmount = Math.round(monthlyWage * (15 / 26) * years);
        
        return [
            i + 1,
            emp.id,
            emp.name,
            formatDateInd(emp.doj),
            years,
            monthlyWage.toLocaleString(),
            years >= 5 ? gratuityAmount.toLocaleString() : `(${gratuityAmount.toLocaleString()})*`
        ];
    });

    generatePDFTableReport(
        "Statement of Liability - LIC Gratuity Group Policy",
        headers,
        data as any[][],
        "Gratuity_Statement",
        'l',
        "* Values in brackets represent accrual for employees with < 5 years of service. Eligibility starts after 5 completed years of service.",
        companyProfile
    );
};

export const generateBonusReport = (
  payrollHistory: PayrollResult[],
  employees: Employee[],
  config: StatutoryConfig,
  startMonth: string,
  startYear: number,
  endMonth: string,
  endYear: number,
  companyProfile: CompanyProfile,
  format: 'PDF' | 'Excel'
) => {
    const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    const startIdx = months.indexOf(startMonth) + (startYear * 12);
    const endIdx = months.indexOf(endMonth) + (endYear * 12);

    const bonusData = employees.map((emp, i) => {
        let totalPaidDays = 0;
        let totalCodeWages = 0;
        let totalActualGross = 0;

        payrollHistory.forEach(r => {
            const rIdx = months.indexOf(r.month) + (r.year * 12);
            if (r.employeeId === emp.id && rIdx >= startIdx && rIdx <= endIdx) {
                const wageA = (r?.earnings?.basic || 0) + (r?.earnings?.da || 0) + (r?.earnings?.retainingAllowance || 0);
                const gross = r?.earnings?.total || 0;
                const excluded = gross - wageA;
                
                let deemedWage = 0;
                if (gross > 0) {
                    const allowancePct = excluded / gross;
                    if (allowancePct > 0.50) {
                        const limit = Math.round(gross * 0.50);
                        const excess = excluded - limit;
                        deemedWage = excess > 0 ? excess : 0;
                    }
                }
                const monthWage = wageA + deemedWage;

                totalPaidDays += r.payableDays;
                totalCodeWages += monthWage;
                totalActualGross += gross;
            }
        });

        if (totalPaidDays === 0) return null;

        const bonusPayable = Math.round(totalCodeWages * config.bonusRate);

        return {
            sl: i + 1,
            id: emp.id,
            name: emp.name,
            designation: emp.designation,
            days: totalPaidDays,
            gross: totalActualGross,
            codeWages: totalCodeWages,
            bonusPct: (config.bonusRate * 100).toFixed(2) + '%',
            bonusAmount: bonusPayable
        };
    }).filter(Boolean);

    const fileName = `Bonus_Register_FormC_${startMonth}${startYear}_${endMonth}${endYear}`;

    if (format === 'Excel') {
        const excelData = bonusData.map((d: any) => ({
            'Sl No': d.sl,
            'Employee ID': d.id,
            'Name': d.name,
            'Designation': d.designation,
            'Total Paid Days': d.days,
            'Total Gross Wages': d.gross,
            'Wages (Clause 88)': d.codeWages,
            'Bonus Rate': d.bonusPct,
            'Bonus Payable': d.bonusAmount
        }));
        generateExcelReport(excelData, 'Bonus Register', fileName);
    } else {
        const headers = ['Sl', 'Emp ID', 'Name', 'Designation', 'Pd Days', 'Gross (Actual)', 'Code Wages (Cl.88)', 'Rate', 'Bonus Payable'];
        const tableData = bonusData.map((d: any) => [
            d.sl, d.id, d.name, d.designation, d.days, 
            d.gross.toLocaleString(), 
            d.codeWages.toLocaleString(), 
            d.bonusPct, 
            d.bonusAmount.toLocaleString()
        ]);

        generatePDFTableReport(
            `Bonus Register (Form C) - ${startMonth} ${startYear} to ${endMonth} ${endYear}`,
            headers,
            tableData,
            fileName,
            'l',
            `* Wages calculated as per Code on Wages 2019, Clause 88 (50% Rule). Bonus Rate: ${(config.bonusRate * 100).toFixed(2)}%`,
            companyProfile
        );
    }
};

export const generateSimplePaySheetPDF = (
  results: PayrollResult[],
  employees: Employee[],
  month: string,
  year: number,
  companyProfile?: CompanyProfile
) => {
  const headers = ['ID', 'Name', 'Days', 'Basic', 'DA', 'HRA', 'Othr', 'GROSS', 'PF', 'ESI', 'PT', 'TDS', 'Adv', 'Fine', 'DED', 'NET PAY'];
  const data = results.map(r => {
    const emp = employees.find(e => e.id === r.employeeId);
    const other = (r?.earnings?.total || 0) - ((r?.earnings?.basic || 0) + (r?.earnings?.da || 0) + (r?.earnings?.hra || 0));
    return [
      r.employeeId, emp?.name || '', r.payableDays, Math.round(r?.earnings?.basic || 0), Math.round(r?.earnings?.da || 0), Math.round(r?.earnings?.hra || 0), Math.round(other), Math.round(r?.earnings?.total || 0), 
      r.isCode88 ? `${Math.round(r?.deductions?.epf || 0)}*` : Math.round(r?.deductions?.epf || 0), 
      r.isESICodeWagesUsed ? `${Math.round(r?.deductions?.esi || 0)}**` : Math.round(r?.deductions?.esi || 0), 
      Math.round(r?.deductions?.pt || 0), Math.round(r?.deductions?.it || 0), 
      Math.round(r?.deductions?.advanceRecovery || 0), Math.round(r?.deductions?.fine || 0), 
      Math.round(r?.deductions?.total || 0), Math.round(r.netPay)
    ];
  });
  let footnote = results.some(r => r.isCode88) ? "* PF calculated on Code Wages. " : "";
  footnote += results.some(r => r.isESICodeWagesUsed) ? "** ESI calculated on Code Wages." : "";
  generatePDFTableReport(`Pay Sheet - ${month} ${year}`, headers, data as any[][], `PaySheet_${month}_${year}`, 'l', footnote || undefined, companyProfile);
};

export const generatePaySlipsPDF = (
  payrollResults: PayrollResult[],
  employees: Employee[],
  month: string,
  year: number,
  companyProfile?: CompanyProfile
) => {
  const doc = new jsPDF('p', 'mm', 'a4');
  payrollResults.forEach((res, index) => {
    if (index > 0) doc.addPage();
    const emp = employees.find(e => e.id === res.employeeId);
    if (!emp) return;

    doc.setFontSize(16); doc.setFont("helvetica", "bold"); doc.setTextColor(30, 41, 59);
    const compName = (companyProfile?.establishmentName || BRAND_CONFIG.companyName).toUpperCase();
    doc.text(compName, 105, 15, { align: 'center' });

    doc.setFontSize(10); doc.setFont("helvetica", "normal"); doc.setTextColor(0);
    const address = buildAddressString(companyProfile);
    doc.text(address, 105, 22, { align: 'center' });

    doc.setFontSize(12);
    doc.text(`PAY SLIP - ${month.toUpperCase()} ${year}`, 105, 32, { align: 'center' });

    autoTable(doc, {
        startY: 40,
        theme: 'grid',
        head: [],
        body: [
            ['Employee Name:', emp.name, 'Designation:', emp.designation],
            ['Employee ID:', emp.id, 'Department:', emp.division || emp.department],
            ['Bank A/c:', emp.bankAccount, 'Days Paid:', `${res.payableDays} / ${res.daysInMonth}`],
            ['UAN No:', emp.uanc || 'N/A', 'PF No:', emp.pfNumber || 'N/A'],
            ['ESI No:', emp.esiNumber || 'N/A', 'PAN No:', emp.pan || 'N/A']
        ],
        styles: { 
            fontSize: 9, 
            cellPadding: 1.5, 
            lineColor: [200, 200, 200], 
            textColor: 0 
        },
        columnStyles: {
            0: { fontStyle: 'bold', cellWidth: 35 },
            1: { cellWidth: 60 },
            2: { fontStyle: 'bold', cellWidth: 35 },
            3: { cellWidth: 60 }
        }
    });

    const earningRows = [
        ['Basic Pay', (res?.earnings?.basic || 0).toFixed(2)],
        ['DA', (res?.earnings?.da || 0).toFixed(2)],
        ['Retaining Allowance', (res?.earnings?.retainingAllowance || 0).toFixed(2)],
        ['HRA', (res?.earnings?.hra || 0).toFixed(2)],
        ['Conveyance', (res?.earnings?.conveyance || 0).toFixed(2)],
        ['Special Allowance', ((res?.earnings?.special1 || 0) + (res?.earnings?.special2 || 0) + (res?.earnings?.special3 || 0)).toFixed(2)],
        ['Other Allowances', ((res?.earnings?.washing || 0) + (res?.earnings?.attire || 0)).toFixed(2)],
        ['Leave Encashment', (res?.earnings?.leaveEncashment || 0).toFixed(2)]
    ];

    const deductionRows = [
        [res.isCode88 ? 'Provident Fund*' : 'Provident Fund', (res?.deductions?.epf || 0).toFixed(2)],
        [res.isESICodeWagesUsed ? 'ESI**' : 'ESI', (res?.deductions?.esi || 0).toFixed(2)],
        ['Professional Tax', (res?.deductions?.pt || 0).toFixed(2)],
        ['Income Tax Recovery', (res?.deductions?.it || 0).toFixed(2)],
        ['VPF', (res?.deductions?.vpf || 0).toFixed(2)],
        ['LWF', (res?.deductions?.lwf || 0).toFixed(2)],
        ['Advance Recovery', (res?.deductions?.advanceRecovery || 0).toFixed(2)],
        ['Fine / Damages', (res?.deductions?.fine || 0).toFixed(2)] 
    ];

    const salaryBody: any[] = earningRows.map((earn, i) => {
        const ded = deductionRows[i] || ['', ''];
        return [earn[0], earn[1], ded[0], ded[1]];
    });

    salaryBody.push([
        { content: 'Total Earnings', styles: { fontStyle: 'bold' } },
        { content: (res?.earnings?.total || 0).toFixed(2), styles: { fontStyle: 'bold' } },
        { content: 'Total Deductions', styles: { fontStyle: 'bold' } },
        { content: (res?.deductions?.total || 0).toFixed(2), styles: { fontStyle: 'bold' } }
    ]);

    autoTable(doc, {
        startY: (doc as any).lastAutoTable.finalY + 5,
        theme: 'grid',
        head: [['Earnings', 'Amount (Rs.)', 'Deductions', 'Amount (Rs.)']],
        body: salaryBody,
        headStyles: { 
            fillColor: [51, 65, 85], 
            textColor: 255, 
            halign: 'center', 
            fontStyle: 'bold' 
        },
        columnStyles: {
            1: { halign: 'right' },
            3: { halign: 'right' }
        },
        styles: { 
            fontSize: 9, 
            cellPadding: 1.5, 
            lineColor: [200, 200, 200], 
            textColor: 0
        }
    });

    const finalY = (doc as any).lastAutoTable.finalY;
    doc.setDrawColor(51, 122, 183); 
    doc.setLineWidth(0.5);
    doc.rect(14, finalY + 5, 182, 12); 

    doc.setFontSize(11); doc.setFont("helvetica", "bold");
    doc.text("NET SALARY PAYABLE:", 20, finalY + 12);
    doc.text(`Rs. ${Math.round(res.netPay).toLocaleString('en-IN')}/-`, 190, finalY + 12, { align: 'right' });

    doc.setFontSize(10); doc.setFont("helvetica", "bold");
    doc.text(`Amount in Words: ${numberToWords(Math.round(res.netPay))} Rupees Only`, 14, finalY + 25);

    doc.setFontSize(8); doc.setFont("helvetica", "italic");
    let noteY = finalY + 32;
    doc.setTextColor(0, 0, 128); 

    if (res.isCode88) {
        doc.text("* PF calculated on Code Wages (Social Security Code 2020)", 14, noteY);
        noteY += 4;
    }
    if (res.isESICodeWagesUsed) {
        doc.text("** ESI calculated on Code Wages (Social Security Code 2020)", 14, noteY);
        noteY += 4;
    }
    if (res.fineReason) {
        doc.setTextColor(220, 38, 38);
        doc.text(`Note: Fine Deduction - ${res.fineReason}`, 14, noteY);
        noteY += 4;
        doc.setTextColor(0, 0, 128);
    }

    doc.setTextColor(150); 
    doc.text("This is a computer-generated document and does not require a signature.", 105, noteY + 5, { align: 'center' });
    doc.setTextColor(0);
  });
  doc.save(`PaySlips_${month}_${year}.pdf`);
};

export const generateLeaveLedgerReport = (
  employees: Employee[],
  ledgers: LeaveLedger[],
  attendances: Attendance[],
  month: string,
  year: number,
  type: 'BC' | 'AC', // Before Confirmation / After Confirmation
  companyProfile: CompanyProfile
) => {
  const headers = ['ID', 'Name', 'Type', 'Opening', 'Credit', 'Used', 'Balance'];
  const data: (string | number)[][] = [];

  employees.forEach(emp => {
    const ledger = ledgers.find(l => l.employeeId === emp.id);
    if (!ledger) return;

    data.push([emp.id, emp.name, 'EL', ledger.el.opening, ledger.el.eligible, ledger.el.availed + ledger.el.encashed, ledger.el.balance]);
    data.push([emp.id, emp.name, 'SL', ledger.sl.eligible, 0, ledger.sl.availed, ledger.sl.balance]); 
    data.push([emp.id, emp.name, 'CL', ledger.cl.accumulation, 0, ledger.cl.availed, ledger.cl.balance]);
  });

  generatePDFTableReport(
    `Leave Ledger Report (${type}) - ${month} ${year}`,
    headers,
    data,
    `Leave_Ledger_${type}_${month}_${year}`,
    'p',
    undefined,
    companyProfile
  );
};

export const generatePFECR = (
  records: PayrollResult[],
  employees: Employee[],
  format: 'Excel' | 'Text',
  fileName: string
) => {
  if (format === 'Excel') {
    const data = records.map(r => {
        const emp = employees.find(e => e.id === r.employeeId);
        return {
            UAN: emp?.uanc,
            Name: emp?.name,
            Gross: r.earnings.total,
            EPF_Wages: Math.min(r.earnings.basic + (r.earnings.da||0), 15000), 
            EE_Share: r.deductions.epf,
            ER_Share_Diff: r.employerContributions.epf,
            ER_Share_Pen: r.employerContributions.eps,
            NCP_Days: r.daysInMonth - r.payableDays
        };
    });
    generateExcelReport(data, 'PF ECR', fileName);
  } else {
    let content = "";
    records.forEach(r => {
        const emp = employees.find(e => e.id === r.employeeId);
        content += `${emp?.uanc}#${emp?.name}#${r.earnings.total}#${r.deductions.epf}#${r.employerContributions.epf}#${r.employerContributions.eps}\n`;
    });
    const blob = new Blob([content], { type: 'text/plain' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${fileName}.txt`;
    a.click();
  }
};

export const generateESIReturn = (
  records: PayrollResult[],
  employees: Employee[],
  format: 'Excel' | 'PDF',
  fileName: string,
  companyProfile: CompanyProfile
) => {
    if (format === 'Excel') {
        const data = records.map(r => {
            const emp = employees.find(e => e.id === r.employeeId);
            
            let reasonCode = 0;
            let dolStr = '';

            // Check if employee left in the current pay period
            if (emp?.dol) {
                const dolDate = new Date(emp.dol);
                const monthIdx = MONTHS.indexOf(r.month);
                if (dolDate.getMonth() === monthIdx && dolDate.getFullYear() === r.year) {
                    reasonCode = 2; // Standard ESI Code for Left Service
                    dolStr = formatDateInd(emp.dol);
                }
            }

            return {
                'IP Number': emp?.esiNumber || '',
                'IP Name': emp?.name || '',
                'No. Of Days': r.payableDays,
                'ESI Wages': Math.round(r.earnings.total), // Monthly Gross Wages
                'Reason': reasonCode,
                'DOL': dolStr
            };
        });
        // Sheet Name explicitly 'Sheet1' as requested
        generateExcelReport(data, 'Sheet1', fileName);
    } else {
        const data = records.map(r => {
            const emp = employees.find(e => e.id === r.employeeId);
            return {
                'IP Number': emp?.esiNumber,
                'Name': emp?.name,
                'Days': r.payableDays,
                'Wages': r.earnings.total, 
                'EE Contribution': r.deductions.esi,
                'ER Contribution': r.employerContributions.esi
            };
        });
        const headers = ['IP No', 'Name', 'Days', 'Wages', 'EE Share', 'ER Share'];
        const rows = data.map(d => Object.values(d));
        generatePDFTableReport('ESI Monthly Contribution', headers, rows as any[][], fileName, 'p', undefined, companyProfile);
    }
};

export const generatePTReport = (
  records: PayrollResult[],
  employees: Employee[],
  fileName: string,
  companyProfile: CompanyProfile
) => {
    const data = records.filter(r => r.deductions.pt > 0).map(r => {
        const emp = employees.find(e => e.id === r.employeeId);
        return {
            'ID': r.employeeId,
            'Name': emp?.name,
            'Gross Wages': r.earnings.total,
            'PT Deducted': r.deductions.pt
        };
    });
    generateExcelReport(data, 'PT Report', fileName);
};

export const generateTDSReport = (
  records: PayrollResult[],
  employees: Employee[],
  fileName: string,
  companyProfile: CompanyProfile
) => {
    const data = records.filter(r => r.deductions.it > 0).map(r => {
        const emp = employees.find(e => e.id === r.employeeId);
        return {
            'ID': r.employeeId,
            'Name': emp?.name,
            'PAN': emp?.pan,
            'Gross Wages': r.earnings.total,
            'TDS Deducted': r.deductions.it
        };
    });
    generateExcelReport(data, 'TDS Report', fileName);
};

export const generateCodeOnWagesReport = (
  records: PayrollResult[],
  employees: Employee[],
  format: 'Excel' | 'PDF',
  fileName: string,
  companyProfile: CompanyProfile
) => {
    const data = records.map(r => {
        const emp = employees.find(e => e.id === r.employeeId);
        return {
            'ID': r.employeeId,
            'Name': emp?.name,
            'Gross': r.earnings.total,
            'Code 88 Applied': r.isCode88 ? 'Yes' : 'No',
            'PF Code Wages': r.isCode88 ? 'Calculated' : 'Standard'
        };
    });
    if (format === 'Excel') generateExcelReport(data, 'Code on Wages', fileName);
    else {
        const headers = Object.keys(data[0] || {});
        const rows = data.map(Object.values);
        generatePDFTableReport('Social Security Code 2020 Compliance', headers, rows as any[][], fileName, 'p', undefined, companyProfile);
    }
};

export const generatePFForm12A = (
  records: PayrollResult[],
  employees: Employee[],
  config: StatutoryConfig,
  companyProfile: CompanyProfile,
  month: string,
  year: number
) => {
    const totalWages = records.reduce((sum, r) => sum + r.earnings.basic + (r.earnings.da || 0), 0);
    const totalPF = records.reduce((sum, r) => sum + r.deductions.epf, 0);
    
    const data = [
        ['Total Subscribers', records.length],
        ['Total Wages', totalWages],
        ['Total PF (EE)', totalPF],
    ];
    
    generatePDFTableReport(`PF Form 12A - ${month} ${year}`, ['Description', 'Value'], data as any[][], `PF_Form12A_${month}_${year}`, 'p', undefined, companyProfile);
};

export const generateFormB = (
  records: PayrollResult[],
  employees: Employee[],
  month: string,
  year: number,
  companyProfile: CompanyProfile
) => {
    const headers = ['Sl', 'Emp ID', 'Name', 'Designation', 'Total Days', 'Total Work Done', 'Basic', 'DA', 'Overtime', 'Other Allow', 'Gross', 'Deductions', 'Net Paid'];
    const data = records.map((r, i) => {
        const emp = employees.find(e => e.id === r.employeeId);
        return [
            i + 1,
            r.employeeId,
            emp?.name || '',
            emp?.designation || '',
            r.payableDays,
            '-',
            r.earnings.basic,
            r.earnings.da || 0,
            0,
            r.earnings.total - (r.earnings.basic + (r.earnings.da || 0)),
            r.earnings.total,
            r.deductions.total,
            r.netPay
        ];
    });
    generatePDFTableReport(`Form B (Register of Wages) - ${month} ${year}`, headers, data as any[][], `Form_B_${month}_${year}`, 'l', undefined, companyProfile);
};

export const generateFormC = (
  records: PayrollResult[],
  employees: Employee[],
  attendances: Attendance[],
  month: string,
  year: number,
  companyProfile: CompanyProfile
) => {
    const headers = ['Sl', 'Emp ID', 'Name', 'Designation', 'Present', 'Leaves', 'Absent', 'Total Days'];
    const data = records.map((r, i) => {
        const emp = employees.find(e => e.id === r.employeeId);
        const att = attendances.find(a => a.employeeId === r.employeeId && a.month === month && a.year === year);
        return [
            i + 1,
            r.employeeId,
            emp?.name || '',
            emp?.designation || '',
            att?.presentDays || 0,
            (att?.earnedLeave || 0) + (att?.sickLeave || 0) + (att?.casualLeave || 0),
            att?.lopDays || 0,
            r.daysInMonth
        ];
    });
    generatePDFTableReport(`Form C (Register of Attendance) - ${month} ${year}`, headers, data as any[][], `Form_C_${month}_${year}`, 'l', undefined, companyProfile);
};

export const generateTNFormR = (
  records: PayrollResult[],
  employees: Employee[],
  month: string,
  year: number,
  companyProfile: CompanyProfile
) => {
    generateFormB(records, employees, month, year, companyProfile);
};

export const generateTNFormT = (
  records: PayrollResult[],
  employees: Employee[],
  attendances: Attendance[],
  ledgers: LeaveLedger[],
  month: string,
  year: number,
  companyProfile: CompanyProfile
) => {
    generateSimplePaySheetPDF(records, employees, month, year, companyProfile);
};

export const generateTNFormP = (
  records: PayrollResult[],
  employees: Employee[],
  advances: AdvanceLedger[],
  month: string,
  year: number,
  companyProfile: CompanyProfile
) => {
    const headers = ['ID', 'Name', 'Adv Date', 'Adv Amount', 'Installments', 'Recovered This Month', 'Balance'];
    const data = records.map(r => {
        const emp = employees.find(e => e.id === r.employeeId);
        const adv = advances.find(a => a.employeeId === r.employeeId);
        if (!adv || r.deductions.advanceRecovery === 0) return null;
        
        return [
            r.employeeId,
            emp?.name || '',
            '-', 
            adv.totalAdvance,
            adv.monthlyInstallment,
            r.deductions.advanceRecovery,
            adv.balance 
        ];
    }).filter(Boolean);
    
    generatePDFTableReport(`TN Form P (Register of Advances) - ${month} ${year}`, headers, data as any[][], `Form_P_${month}_${year}`, 'l', undefined, companyProfile);
};

export const generatePFForm3A = (
  records: PayrollResult[],
  employees: Employee[],
  config: StatutoryConfig,
  startMonth: string,
  startYear: number,
  endMonth: string,
  endYear: number,
  selectedEmpId: string | undefined,
  companyProfile: CompanyProfile
) => {
    const data = [['Month', 'Wages', 'EPF', 'EPS', 'ER PF']];
    generatePDFTableReport(`PF Form 3A`, data[0], [], `Form_3A`, 'p', undefined, companyProfile);
};

export const generatePFForm6A = (
  records: PayrollResult[],
  employees: Employee[],
  config: StatutoryConfig,
  startMonth: string,
  startYear: number,
  endMonth: string,
  endYear: number,
  companyProfile: CompanyProfile
) => {
    const headers = ['UAN', 'Name', 'Gross Wages', 'EPF Wages', 'EE Share', 'ER Share', 'Remitted'];
    generatePDFTableReport(`PF Form 6A (Consolidated Annual)`, headers, [], `Form_6A`, 'l', undefined, companyProfile);
};

export const generateESIExitReport = (
  records: PayrollResult[],
  employees: Employee[],
  month: string,
  year: number,
  companyProfile: CompanyProfile
) => {
    const data = records.filter(r => {
        const emp = employees.find(e => e.id === r.employeeId);
        return emp?.dol || (r.earnings.total > 21000 && !emp?.isESIExempt);
    }).map(r => {
        const emp = employees.find(e => e.id === r.employeeId);
        return {
            ID: emp?.id,
            Name: emp?.name,
            Reason: emp?.dol ? 'Left Service' : 'Exceeded Ceiling',
            Date: emp?.dol || `${month} ${year}`
        };
    });
    
    generateExcelReport(data, 'ESI Exit Report', `ESI_Exit_${month}_${year}`);
};

export const generateESICodeWagesReport = (
  records: PayrollResult[],
  employees: Employee[],
  format: 'Excel' | 'PDF',
  fileName: string,
  companyProfile: CompanyProfile
) => {
    const data = records.filter(r => r.isESICodeWagesUsed).map(r => {
        const emp = employees.find(e => e.id === r.employeeId);
        return {
            ID: r.employeeId,
            Name: emp?.name,
            Gross: r.earnings.total,
            'Code Wages': 'Calculated per Clause 88'
        };
    });
    
    if (format === 'Excel') generateExcelReport(data, 'ESI Code Wages', fileName);
    else {
        const headers = ['ID', 'Name', 'Gross', 'Remarks'];
        const rows = data.map(d => Object.values(d));
        generatePDFTableReport('ESI Code Wages Applicability', headers, rows as any[][], fileName, 'p', undefined, companyProfile);
    }
};
